name: 'BBL Up'
description: 'Set up test environment using BBL (GCP)'

inputs:
  stack:
    description: 'Stack name'
    required: true
  version:
    description: 'Version number'
    required: true
  env_name:
    description: 'Environment name'
    required: false
    default: 'cflinuxfs5-test'
  gcp_project_id:
    description: 'GCP Project ID'
    required: true
  gcp_zone:
    description: 'GCP Zone'
    required: false
    default: 'us-east1-c'
  gcp_region:
    description: 'GCP Region'
    required: false
    default: 'us-east1'
  lb_domain:
    description: 'Load balancer domain'
    required: false
    default: ''
  bbl_state_repo:
    description: 'Repo for BBL state (owner/repo)'
    required: true
  bbl_state_branch:
    description: 'Branch for BBL state'
    required: false
    default: 'main'

runs:
  using: 'composite'
  steps:
    - name: Checkout cf-deployment-concourse-tasks
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/cf-deployment-concourse-tasks
        ref: main
        path: cf-deployment-concourse-tasks

    - name: Checkout bosh-deployment
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/bosh-deployment
        ref: master
        path: bosh-deployment

    - name: Checkout BBL state repo
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.bbl_state_repo }}
        ref: ${{ inputs.bbl_state_branch }}
        path: bbl-state
        ssh-key: ${{ env.BBL_STATE_DEPLOY_KEY }}

    - name: Install BBL, Terraform, BOSH CLI, and tools
      shell: bash
      run: |
        set -euo pipefail
        
        # Install BBL
        wget -O /tmp/bbl https://github.com/Ivo1116/bosh-bootloader/releases/download/test/bbl-linux
        chmod +x /tmp/bbl
        sudo mv /tmp/bbl /usr/local/bin/bbl

        # Install Terraform
        wget -O /tmp/terraform.zip https://releases.hashicorp.com/terraform/1.5.7/terraform_1.5.7_linux_amd64.zip
        unzip /tmp/terraform.zip -d /tmp/
        sudo mv /tmp/terraform /usr/local/bin/terraform
        sudo chmod +x /usr/local/bin/terraform

        # Install BOSH CLI
        wget -O /tmp/bosh https://github.com/cloudfoundry/bosh-cli/releases/download/v7.4.0/bosh-cli-7.4.0-linux-amd64
        chmod +x /tmp/bosh
        sudo mv /tmp/bosh /usr/local/bin/bosh

        # Install gcloud CLI for troubleshooting
        curl -sSL https://sdk.cloud.google.com | bash
        echo 'source /home/runner/google-cloud-sdk/path.bash.inc' >> ~/.bashrc
        export PATH="/home/runner/google-cloud-sdk/bin:$PATH"

    - name: Create enhanced terraform configuration
      shell: bash
      run: |
        mkdir -p bbl-state/${{ inputs.env_name }}/terraform
        
        # Add additional firewall rules for better jumpbox connectivity
        cat > bbl-state/${{ inputs.env_name }}/terraform/jumpbox-connectivity.tf << 'EOF'
        # Additional firewall rules for jumpbox connectivity
        resource "google_compute_firewall" "jumpbox_debug_all" {
          name    = "${var.env_id}-jumpbox-debug-all"
          network = "${google_compute_network.bbl-network.name}"

          allow {
            protocol = "tcp"
            ports    = ["22", "6868", "8080", "8443"]
          }

          allow {
            protocol = "icmp"
          }

          source_ranges = ["0.0.0.0/0"]
          target_tags   = ["${var.env_id}-jumpbox"]
          priority      = 500
          direction     = "INGRESS"
          description   = "Debug access to jumpbox"
        }

        # Allow all egress from jumpbox
        resource "google_compute_firewall" "jumpbox_egress_all" {
          name    = "${var.env_id}-jumpbox-egress-all"
          network = "${google_compute_network.bbl-network.name}"

          allow {
            protocol = "tcp"
          }

          allow {
            protocol = "udp"
          }

          allow {
            protocol = "icmp"
          }

          destination_ranges = ["0.0.0.0/0"]
          source_tags        = ["${var.env_id}-jumpbox"]
          priority           = 500
          direction          = "EGRESS"
          description        = "Allow all egress from jumpbox"
        }
        EOF

    - name: Run BBL Up with jumpbox monitoring
      id: bbl-up
      shell: bash
      env:
        GCP_SERVICE_ACCOUNT_KEY: ${{ env.GCP_SERVICE_ACCOUNT_KEY }}
        CFLINUXFS5_LB_CERT: ${{ env.CFLINUXFS5_LB_CERT }}
        CFLINUXFS5_LB_KEY: ${{ env.CFLINUXFS5_LB_KEY }}
      run: |
        set -euo pipefail

        mkdir -p bbl-state/${{ inputs.env_name }}
        cd bbl-state/${{ inputs.env_name }}

        # Setup GCP credentials
        echo "${GCP_SERVICE_ACCOUNT_KEY}" > gcp-key.json
        export BBL_GCP_SERVICE_ACCOUNT_KEY="$(pwd)/gcp-key.json"
        export BBL_GCP_PROJECT_ID="${{ inputs.gcp_project_id }}"
        export BBL_GCP_ZONE="${{ inputs.gcp_zone }}"
        export BBL_GCP_REGION="${{ inputs.gcp_region }}"
        export BBL_IAAS=gcp

        # Setup gcloud
        export PATH="/home/runner/google-cloud-sdk/bin:$PATH"
        gcloud auth activate-service-account --key-file=gcp-key.json
        gcloud config set project ${{ inputs.gcp_project_id }}

        # Setup LB cert/key if provided
        if [[ -n "${CFLINUXFS5_LB_CERT:-}" && -n "${CFLINUXFS5_LB_KEY:-}" ]]; then
          echo "${CFLINUXFS5_LB_CERT}" > lb-cert.pem
          echo "${CFLINUXFS5_LB_KEY}" > lb-key.pem
          export BBL_LB_CERT="$(pwd)/lb-cert.pem"
          export BBL_LB_KEY="$(pwd)/lb-key.pem"
        fi

        # Setup LB domain if provided
        if [[ -n "${{ inputs.lb_domain }}" ]]; then
          export LB_DOMAIN="${{ inputs.lb_domain }}"
        fi

        # Function to get jumpbox IP from GCP
        get_jumpbox_ip_from_gcp() {
          local env_prefix=""
          
          # Try to get env prefix from existing state
          if [ -f vars/bbl.tfvars ]; then
            env_prefix=$(grep 'env_id' vars/bbl.tfvars | cut -d'"' -f2 || echo "")
          fi
          
          if [[ -z "$env_prefix" ]]; then
            # Generate expected prefix from current time (BBL style)
            env_prefix="bbl-env-${{ inputs.env_name }}-$(date -u +%Y-%m-%dt%H-%Mz | tr '[:upper:]' '[:lower:]')"
          fi
          
          echo "Looking for jumpbox with prefix: $env_prefix"
          
          # Find jumpbox VM
          local jumpbox_ip=$(gcloud compute instances list \
            --filter="name~$env_prefix.*jumpbox OR labels.job=jumpbox" \
            --format="value(networkInterfaces[0].accessConfigs[0].natIP)" \
            --limit=1 2>/dev/null || echo "")
          
          if [[ -n "$jumpbox_ip" ]]; then
            echo "Found jumpbox IP from GCP: $jumpbox_ip"
            echo "$jumpbox_ip"
          else
            echo "No jumpbox IP found in GCP"
            echo ""
          fi
        }

        # Function to wait for VM to be fully ready
        wait_for_vm_ready() {
          local vm_name="$1"
          local max_attempts=60
          local attempt=1
          
          echo "Waiting for VM $vm_name to be fully ready..."
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts: Checking VM status..."
            
            # Check if VM is running
            local vm_status=$(gcloud compute instances describe "$vm_name" \
              --format="value(status)" 2>/dev/null || echo "NOT_FOUND")
            
            if [[ "$vm_status" != "RUNNING" ]]; then
              echo "VM status: $vm_status (waiting for RUNNING)"
              sleep 10
              attempt=$((attempt + 1))
              continue
            fi
            
            # Check if BOSH agent is responding
            if gcloud compute instances get-serial-port-output "$vm_name" \
              --start=0 2>/dev/null | grep -q "INFO.*Starting BOSH Agent\|INFO.*bosh-agent.*started"; then
              echo "BOSH agent is started"
              return 0
            fi
            
            echo "VM is running but BOSH agent not ready yet..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          echo "VM failed to become ready after $max_attempts attempts"
          return 1
        }

        # Function to test and fix jumpbox connectivity
        test_and_fix_jumpbox() {
          local jumpbox_ip="$1"
          echo "Testing jumpbox connectivity to $jumpbox_ip..."
          
          # Get SSH key
          if ! bbl ssh-key > /tmp/jumpbox_key 2>/dev/null; then
            echo "Could not get SSH key from BBL"
            return 1
          fi
          chmod 600 /tmp/jumpbox_key
          
          # Test SSH connectivity with timeout
          local max_attempts=30
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "SSH test attempt $attempt/$max_attempts..."
            
            if timeout 10 ssh -i /tmp/jumpbox_key \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ConnectTimeout=10 \
              -o BatchMode=yes \
              jumpbox@"$jumpbox_ip" \
              "echo 'SSH connection successful'" 2>/dev/null; then
              
              echo "SSH connection successful!"
              
              # Configure jumpbox for better connectivity
              echo "Configuring jumpbox for optimal performance..."
              ssh -i /tmp/jumpbox_key \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null \
                -o ConnectTimeout=30 \
                jumpbox@"$jumpbox_ip" << 'JUMPBOX_EOF'
              # Configure SSH for stability
              sudo tee -a /etc/ssh/sshd_config << SSH_CONFIG_EOF
              ClientAliveInterval 30
              ClientAliveCountMax 6
              TCPKeepAlive yes
              GatewayPorts yes
              AllowTcpForwarding yes
              MaxSessions 100
              MaxStartups 100:30:200
              SSH_CONFIG_EOF
              
              # Restart SSH
              sudo systemctl restart ssh || sudo service ssh restart
              
              # Test internet connectivity
              echo "Testing internet connectivity..."
              curl -s --connect-timeout 10 --max-time 30 https://google.com >/dev/null && echo "Internet: OK"
              curl -s --connect-timeout 10 --max-time 30 https://s3.amazonaws.com >/dev/null && echo "S3: OK"
              curl -s --connect-timeout 10 --max-time 30 https://github.com >/dev/null && echo "GitHub: OK"
              
              echo "Jumpbox configuration completed"
              JUMPBOX_EOF
              
              rm -f /tmp/jumpbox_key
              return 0
            fi
            
            echo "SSH connection failed, waiting 10 seconds..."
            sleep 10
            attempt=$((attempt + 1))
          done
          
          rm -f /tmp/jumpbox_key
          echo "SSH connectivity test failed after $max_attempts attempts"
          return 1
        }

        # Function to restart jumpbox VM if needed
        restart_jumpbox_if_needed() {
          local jumpbox_ip="$1"
          
          echo "Jumpbox appears unresponsive, attempting to restart..."
          
          # Find jumpbox VM name
          local vm_name=$(gcloud compute instances list \
            --filter="networkInterfaces.accessConfigs.natIP=$jumpbox_ip" \
            --format="value(name)" --limit=1)
          
          if [[ -n "$vm_name" ]]; then
            echo "Found jumpbox VM: $vm_name"
            
            # Stop and start the VM
            echo "Stopping jumpbox VM..."
            gcloud compute instances stop "$vm_name" --quiet || true
            sleep 30
            
            echo "Starting jumpbox VM..."
            gcloud compute instances start "$vm_name" --quiet
            
            # Wait for VM to be ready
            if wait_for_vm_ready "$vm_name"; then
              echo "Jumpbox VM restarted successfully"
              sleep 30  # Additional wait for services
              return 0
            else
              echo "Jumpbox VM failed to restart properly"
              return 1
            fi
          else
            echo "Could not find jumpbox VM to restart"
            return 1
          fi
        }

        # Check if already exists and working
        if [ -f bbl-state.json ] && bbl print-env >/dev/null 2>&1; then
          echo "Infrastructure already exists and is working"
          echo "success=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Main BBL up logic with jumpbox monitoring
        max_attempts=3
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "BBL up attempt $attempt of $max_attempts"
          
          # Start BBL up in background
          echo "Starting BBL up..."
          timeout 1800 bbl up --debug --terraform-binary /usr/local/bin/terraform \
            ${BBL_LB_CERT:+--lb-cert "$BBL_LB_CERT"} \
            ${BBL_LB_KEY:+--lb-key "$BBL_LB_KEY"} \
            ${LB_DOMAIN:+--lb-domain "$LB_DOMAIN"} &
          
          BBL_PID=$!
          jumpbox_monitored=false
          
          # Monitor BBL progress and jumpbox creation
          while kill -0 $BBL_PID 2>/dev/null; do
            # Check if jumpbox was created
            if [[ "$jumpbox_monitored" == "false" ]]; then
              jumpbox_ip=$(get_jumpbox_ip_from_gcp)
              
              if [[ -n "$jumpbox_ip" ]]; then
                echo "Jumpbox detected at $jumpbox_ip"
                jumpbox_monitored=true
                
                # Test jumpbox connectivity
                if test_and_fix_jumpbox "$jumpbox_ip"; then
                  echo "Jumpbox is ready and configured"
                else
                  echo "Jumpbox connectivity failed, attempting restart..."
                  if restart_jumpbox_if_needed "$jumpbox_ip"; then
                    echo "Jumpbox restarted, testing connectivity again..."
                    sleep 30
                    test_and_fix_jumpbox "$jumpbox_ip" || echo "Jumpbox still not responsive"
                  fi
                fi
              fi
            fi
            
            sleep 10
          done
          
          # Wait for BBL to complete
          if wait $BBL_PID; then
            echo "BBL up succeeded on attempt $attempt"
            break
          else
            echo "BBL up failed on attempt $attempt"
            
            # Try to fix jumpbox if it exists
            jumpbox_ip=$(get_jumpbox_ip_from_gcp)
            if [[ -n "$jumpbox_ip" ]]; then
              echo "Jumpbox exists, attempting to fix connectivity..."
              if restart_jumpbox_if_needed "$jumpbox_ip"; then
                test_and_fix_jumpbox "$jumpbox_ip"
              fi
            fi
            
            if [ $attempt -eq $max_attempts ]; then
              echo "All BBL up attempts failed"
              exit 1
            fi
            
            echo "Waiting 60 seconds before retry..."
            sleep 60
            attempt=$((attempt + 1))
          fi
        done

        echo "success=true" >> $GITHUB_OUTPUT

    - name: Commit and push BBL state
      shell: bash
      run: |
        set -euo pipefail
        cd bbl-state
        git config user.name "CF Buildpacks Eng Bot"
        git config user.email "tanzu-buildpacks.pdl@broadcom.com"
        if [[ -n "$(git status --porcelain)" ]]; then
          git add -A
          git commit -m "Update BBL state for ${{ inputs.env_name }}"
          git push origin ${{ inputs.bbl_state_branch }}
        else
          echo "No BBL state changes to commit."
        fi

    - name: Output BBL environment info
      shell: bash
      run: |
        cd bbl-state/${{ inputs.env_name }}
        bbl print-env
