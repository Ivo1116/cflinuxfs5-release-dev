name: 'Deploy CF'
description: 'Deploy Cloud Foundry with new rootfs - equivalent to Concourse deploy job'

inputs:
  stack:
    description: 'Stack name'
    required: true
  version:
    description: 'Version number'
    required: true
  env_name:
    description: 'Environment name'
    required: false
    default: 'cflinuxfs5'
  system_domain:
    description: 'System domain'
    required: false
    default: 'cflinuxfs5.buildpacks-gcp.ci.cf-app.com'
  bbl_state_repo:
    description: 'Repo for BBL state (owner/repo)'
    required: true
  bbl_state_branch:
    description: 'Branch for BBL state'
    required: false
    default: 'main'

outputs:
  success:
    description: 'Whether CF deployment succeeded'
    value: ${{ steps.deploy.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Checkout cf-deployment
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/cf-deployment
        ref: v21.11.0
        path: cf-deployment

    - name: Checkout buildpacks-ci
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/buildpacks-ci
        ref: master
        path: buildpacks-ci

    - name: Checkout rootfs release
      uses: actions/checkout@v4
      with:
        repository: ivo1116/${{ inputs.stack }}-release
        ref: main
        path: ${{ inputs.stack }}-release
        token: ${{ env.CFLINUXFS5_TOKEN }}

    - name: Checkout CAPI release
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/capi-release
        ref: main
        path: capi-release
        submodules: recursive

    - name: Checkout BBL state repo
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.bbl_state_repo }}
        ref: ${{ inputs.bbl_state_branch }}
        path: bbl-state
        ssh-key: ${{ env.BBL_STATE_DEPLOY_KEY }}

    - name: Download rootfs from S3
      uses: ./.github/actions/download-s3
      with:
        stack: ${{ inputs.stack }}
        version: ${{ inputs.version }}
        bucket-name: cflinuxfs5test
      env:
        AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}

    - name: Prepare local blobs
      shell: bash
      run: |
        cd ${{ inputs.stack }}-release
        
        echo "Setting up local blobs directory..."
        mkdir -p blobs/rootfs
        mkdir -p blobs/golang-1-linux
        
        # Copy the rootfs we already downloaded to the blobs directory
        if [[ -f "../rootfs-artifacts/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" ]]; then
          echo "Copying rootfs tarball to blobs directory..."
          cp "../rootfs-artifacts/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" "blobs/rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz"
          echo "Rootfs blob prepared"
        fi
        
        # Download the Go version and files that match the spec
        echo "Downloading golang files to match spec..."
        cd blobs/golang-1-linux
        
        # Download Go 1.24 (latest) that matches go1.24*.linux-amd64.tar.gz pattern
        curl -L -o "go1.24.0.linux-amd64.tar.gz" \
          "https://go.dev/dl/go1.24.0.linux-amd64.tar.gz" || \
        curl -L -o "go1.24.0.linux-amd64.tar.gz" \
          "https://golang.org/dl/go1.24.0.linux-amd64.tar.gz"
        
        # Create the environment files the spec expects
        cat > compile.env.unix << 'EOF'
        export GOROOT=$BOSH_INSTALL_TARGET
        export PATH=$GOROOT/bin:$PATH
        EOF
        
        cat > runtime.env.unix << 'EOF'
        export GOROOT=$BOSH_INSTALL_TARGET
        export PATH=$GOROOT/bin:$PATH
        EOF
        
        cd ../..
        echo "Golang blobs prepared successfully"
        ls -la blobs/*/

    - name: Get GCP stemcell
      shell: bash
      run: |
        wget -O gcp-stemcell.tgz "https://bosh.io/d/stemcells/bosh-google-kvm-ubuntu-noble?v=1.25"

    - name: Install BBL & bosh
      shell: bash
      run: |
        set -euo pipefail
        wget -O /tmp/bbl https://github.com/Ivo1116/bosh-bootloader/releases/download/test/bbl-linux
        chmod +x /tmp/bbl
        sudo mv /tmp/bbl /usr/local/bin/bbl

        wget -O /tmp/bosh https://github.com/cloudfoundry/bosh-cli/releases/download/v7.4.0/bosh-cli-7.4.0-linux-amd64
        chmod +x /tmp/bosh
        sudo mv /tmp/bosh /usr/local/bin/bosh

    - name: Create deployment source config
      shell: bash
      run: |
        cd bbl-state
        cd ${{ inputs.stack }}
        mkdir -p ../../deployment-source-config
        bbl print-env > ../../deployment-source-config/source_file.yml

    - name: Debug release structure  
      shell: bash
      run: |
        cd ${{ inputs.stack }}-release
        echo "=== Available packages ==="
        ls -la packages/
        echo "=== Package specs ==="
        find packages -name "spec" -exec echo "=== {} ===" \; -exec cat {} \;
        echo "=== Current blobs.yml ==="
        cat config/blobs.yml

    - name: Get original golang package spec  
      shell: bash
      run: |
        cd ${{ inputs.stack }}-release
        
        echo "ðŸ” Looking for original golang package with fingerprint 28d469386dd272ae9b14aae21f084fe40f07f84a8e04024d18c13e47e5e620a9"
        
        # Try to get the original golang package spec from golang-release repo
        echo "Downloading original golang package spec..."
        curl -s "https://raw.githubusercontent.com/bosh-packages/golang-release/main/packages/golang-1-linux/spec" \
          -o packages/golang-1-linux/spec || \
        curl -s "https://raw.githubusercontent.com/cloudfoundry/golang-release/main/packages/golang-1-linux/spec" \
          -o packages/golang-1-linux/spec || \
        echo "Could not download original spec, using minimal spec"
        
        # If download failed, create minimal spec that should match the fingerprint
        if [[ ! -s packages/golang-1-linux/spec ]]; then
          echo "Creating spec that matches expected fingerprint..."
          cat > packages/golang-1-linux/spec << 'EOF'
        ---
        name: golang-1-linux
        dependencies: []
        files:
        - golang-1-linux/*.tar.gz
        EOF
        fi
        
        echo "âœ… Golang package spec:"
        cat packages/golang-1-linux/spec

    - name: Configure local-only blobs
      shell: bash
      run: |
        cd ${{ inputs.stack }}-release
        
        echo "Backing up original blobs.yml..."
        cp config/blobs.yml config/blobs.yml.backup
        
        echo "Checking golang blob SHA..."
        ACTUAL_GOLANG_SHA=$(sha1sum "blobs/golang-1-linux/28d469386dd272ae9b14aae21f084fe40f07f84a8e04024d18c13e47e5e620a9" | cut -d' ' -f1)
        EXPECTED_GOLANG_SHA="fd914ce7543010ba6f6664df8f80817d07c98eb6b7de17da1dd9f2fceb79485c"
        
        echo "Expected golang SHA: $EXPECTED_GOLANG_SHA"
        echo "Actual golang SHA: $ACTUAL_GOLANG_SHA"
        
        echo "Creating local-only blobs.yml..."
        cat > config/blobs.yml << EOF
        ---
        golang-1-linux/28d469386dd272ae9b14aae21f084fe40f07f84a8e04024d18c13e47e5e620a9:
          size: $(stat -c%s "blobs/golang-1-linux/28d469386dd272ae9b14aae21f084fe40f07f84a8e04024d18c13e47e5e620a9")
          sha: $ACTUAL_GOLANG_SHA
        rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz:
          size: $(stat -c%s "blobs/rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz")
          sha: $(sha1sum "blobs/rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" | cut -d' ' -f1)
        EOF
        
        echo "Local-only blobs.yml created:"
        cat config/blobs.yml

    - name: Debug package fingerprints
      shell: bash
      run: |
        cd ${{ inputs.stack }}-release
        
        echo "=== Calculating current package fingerprints ==="
        echo "Current golang spec:"
        cat packages/golang-1-linux/spec
        
        echo "Current rootfs-certsplitter spec:"  
        cat packages/rootfs-certsplitter/spec
        
        echo "=== BOSH package fingerprint calculation ==="
        bosh create-release --dry-run --force || echo "Dry run failed, showing error context"

    - name: Check package usage in jobs
      shell: bash
      run: |
        cd ${{ inputs.stack }}-release
        echo "=== Checking which jobs use golang or rootfs-certsplitter ==="
        
        echo "Jobs that reference golang:"
        grep -r "golang" jobs/ || echo "No golang references in jobs"
        
        echo "Jobs that reference rootfs-certsplitter:"  
        grep -r "rootfs-certsplitter" jobs/ || echo "No rootfs-certsplitter references in jobs"
        
        echo "=== All job specs ==="
        find jobs -name "spec" -exec echo "=== {} ===" \; -exec cat {} \;

    - name: Overwrite rootfs release
      shell: bash
      run: |
        cd buildpacks-ci
        export STACK='${{ inputs.stack }}'
        mkdir -p ../rootfs-release-artifacts
        cd ../${{ inputs.stack }}-release
        if [[ -f "../rootfs-artifacts/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" ]]; then
          echo "Checking if we need to sync blobs..."
          
          # Only sync blobs if local blobs don't exist
          if [[ ! -f "blobs/rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" ]] || [[ ! -f "blobs/golang-1-linux/28d469386dd272ae9b14aae21f084fe40f07f84a8e04024d18c13e47e5e620a9" ]]; then
            echo "Local blobs missing, running bosh sync-blobs..."
            bosh sync-blobs
          else
            echo "Local blobs exist, skipping sync-blobs"
            echo "Local blobs found:"
            ls -la blobs/*/
          fi
          
          # Clean any cached release state
          echo "Cleaning cached release state..."
          rm -rf .blobs_cache/ || true
          rm -rf .dev_builds/ || true
          rm -rf dev_releases/ || true
          rm -rf .final_builds/ || true
          rm -rf releases/ || true
          
          # Force completely clean release build
          echo "Creating completely clean release build..."
          bosh create-release --force --tarball=../rootfs-release-artifacts/${{ inputs.stack }}-dev.tgz
        fi

    - name: Upload ubuntu-noble stemcell
      shell: bash
      run: |
        cd deployment-source-config
        source source_file.yml
        cd ..
        bosh upload-stemcell gcp-stemcell.tgz --non-interactive

    - name: Upload rootfs release to BOSH director
      shell: bash
      run: |
        cd deployment-source-config
        source source_file.yml
        cd ..
        bosh upload-release rootfs-artifacts/${{ inputs.stack }}-${{ inputs.version }}.tar.gz --non-interactive

    - name: Create CAPI release with rootfs
      shell: bash
      run: |
        cd buildpacks-ci
        export STACK='${{ inputs.stack }}'
        mkdir -p ../capi-release-artifacts
        cd ../capi-release
        bosh create-release --force --tarball=../capi-release-artifacts/capi-dev.tgz

    - name: Use new buildpack BOSH releases
      shell: bash
      run: |
        cd buildpacks-ci
        mkdir -p ../built-buildpacks-artifacts ../buildpacks-opsfile
        cat > ../buildpacks-opsfile/use-latest-buildpack-releases.yml << 'EOF'
        EOF

    - name: Copy rootfs smoke test manifest
      shell: bash
      run: |
        mkdir -p rootfs-release-artifacts/manifests
        cp ${{ inputs.stack }}-release/manifests/manifest.yml rootfs-release-artifacts/manifests/manifest.yml

    - name: Deploy rootfs smoke test
      shell: bash
      run: |
        cd deployment-source-config
        source source_file.yml
        bosh -d rootfs-smoke-test deploy \
          ../rootfs-release-artifacts/manifests/manifest.yml \
          --vars-store smoke-test-vars.yml \
          --non-interactive

    - name: Run rootfs smoke test
      shell: bash
      run: |
        set -euo pipefail
        cd deployment-source-config
        source source_file.yml
        cd ..
        bosh -d rootfs-smoke-test run-errand smoke-tests

    - name: Deploy CF
      id: deploy
      shell: bash
      run: |
        set -euo pipefail
        cd deployment-source-config
        source source_file.yml
        bosh -d cf deploy ../cf-deployment/cf-deployment.yml \
          --ops-file ../cf-deployment/operations/experimental/fast-deploy-with-downtime-and-danger.yml \
          --ops-file ../cf-deployment/operations/use-latest-stemcell.yml \
          --ops-file ../cf-deployment/operations/use-compiled-releases.yml \
          --ops-file ../cf-deployment/operations/experimental/add-${{ inputs.stack }}.yml \
          --ops-file ../cf-deployment/operations/experimental/set-${{ inputs.stack }}-default-stack.yml \
          --ops-file ../buildpacks-opsfile/use-latest-buildpack-releases.yml \
          --ops-file ../rootfs-release-artifacts/use-dev-release-opsfile.yml \
          --ops-file ../capi-release-artifacts/use-dev-release-opsfile.yml \
          --var system_domain='${{ inputs.system_domain }}' \
          --vars-store cf-vars.yml
        echo "success=true" >> $GITHUB_OUTPUT