name: 'Deploy CF'
description: 'Deploy Cloud Foundry with new rootfs - equivalent to Concourse deploy job'

inputs:
  stack:
    description: 'Stack name'
    required: true
  version:
    description: 'Version number'
    required: true
  env_name:
    description: 'Environment name'
    required: false
    default: 'cflinuxfs5'
  system_domain:
    description: 'System domain'
    required: false
    default: 'cflinuxfs5.buildpacks-gcp.ci.cf-app.com'
  bbl_state_repo:
    description: 'Repo for BBL state (owner/repo)'
    required: true
  bbl_state_branch:
    description: 'Branch for BBL state'
    required: false
    default: 'main'

outputs:
  success:
    description: 'Whether CF deployment succeeded'
    value: ${{ steps.deploy.outputs.success }}

runs:
  using: 'composite'
  steps:
    - name: Checkout cf-deployment
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/cf-deployment
        ref: v21.11.0
        path: cf-deployment

    - name: Checkout buildpacks-ci
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/buildpacks-ci
        ref: master
        path: buildpacks-ci

    - name: Checkout rootfs release
      uses: actions/checkout@v4
      with:
        repository: ivo1116/${{ inputs.stack }}-release
        ref: main
        path: ${{ inputs.stack }}-release
        token: ${{ env.CFLINUXFS5_TOKEN }}

    - name: Checkout CAPI release
      uses: actions/checkout@v4
      with:
        repository: cloudfoundry/capi-release
        ref: main
        path: capi-release
        submodules: recursive

    - name: Checkout BBL state repo
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.bbl_state_repo }}
        ref: ${{ inputs.bbl_state_branch }}
        path: bbl-state
        ssh-key: ${{ env.BBL_STATE_DEPLOY_KEY }}

    - name: Download rootfs from S3
      uses: ./.github/actions/download-s3
      with:
        stack: ${{ inputs.stack }}
        version: ${{ inputs.version }}
        bucket-name: cflinuxfs5test
      env:
        AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}

    - name: Get GCP stemcell
      shell: bash
      run: |
        wget -O gcp-stemcell.tgz "https://bosh.io/d/stemcells/bosh-google-kvm-ubuntu-noble?v=1.25"

    - name: Install BBL & bosh
      shell: bash
      run: |
        set -euo pipefail
        wget -O /tmp/bbl https://github.com/Ivo1116/bosh-bootloader/releases/download/test/bbl-linux
        chmod +x /tmp/bbl
        sudo mv /tmp/bbl /usr/local/bin/bbl

        wget -O /tmp/bosh https://github.com/cloudfoundry/bosh-cli/releases/download/v7.4.0/bosh-cli-7.4.0-linux-amd64
        chmod +x /tmp/bosh
        sudo mv /tmp/bosh /usr/local/bin/bosh

    - name: Create deployment source config
      shell: bash
      run: |
        cd bbl-state/${{ inputs.stack }}
        mkdir -p ../../deployment-source-config
        bbl print-env > ../../deployment-source-config/source_file.yml

    - name: Setup directories and check files
      shell: bash
      run: |
        mkdir -p rootfs-release-artifacts/manifests
        mkdir -p capi-release-artifacts
        mkdir -p buildpacks-opsfile
        
        echo "=== Current directory contents ==="
        ls -la
        echo "=== Rootfs artifacts contents ==="
        ls -la rootfs-artifacts/ || echo "No rootfs-artifacts directory"
        echo "=== Looking for rootfs tarball ==="
        find . -name "*${{ inputs.stack }}*${{ inputs.version }}*" -type f || echo "No rootfs files found"

    - name: Create rootfs release (complete cleanup)
      shell: bash
      run: |
        cd ${{ inputs.stack }}-release
        
        # Copy the rootfs tarball to the expected location in the release
        if [[ -f "../rootfs-artifacts/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" ]]; then
          echo "Found rootfs tarball, copying to blobs directory"
          mkdir -p blobs/rootfs
          
          # Copy rootfs with the versioned filename
          cp "../rootfs-artifacts/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" "blobs/rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz"
          cp "../rootfs-artifacts/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" "blobs/rootfs/${{ inputs.stack }}.tar.gz"
          
          echo "=== Original release structure ==="
          echo "Packages:"
          ls -la packages/ || echo "No packages directory"
          echo "Jobs:"
          ls -la jobs/ || echo "No jobs directory"
          
          # First, identify and remove all packages that depend on golang
          echo "=== Removing golang-dependent packages ==="
          GOLANG_PACKAGES=""
          if [[ -d "packages" ]]; then
            for pkg_dir in packages/*/; do
              if [[ -f "$pkg_dir/spec" ]] && (grep -q "golang-1-linux" "$pkg_dir/spec" || grep -q "golang" "$pkg_dir/spec"); then
                pkg_name=$(basename "$pkg_dir")
                echo "Found golang-dependent package: $pkg_name"
                GOLANG_PACKAGES="$GOLANG_PACKAGES $pkg_name"
                rm -rf "$pkg_dir"
                echo "Removed package: $pkg_name"
              fi
            done
          fi
          
          echo "Golang-dependent packages removed: $GOLANG_PACKAGES"
          
          # Now update all job specs to remove references to these packages
          echo "=== Updating job specifications ==="
          if [[ -d "jobs" ]]; then
            for job_dir in jobs/*/; do
              job_name=$(basename "$job_dir")
              if [[ -f "$job_dir/spec" ]]; then
                echo "Processing job: $job_name"
                
                # Remove golang package references
                sed -i '/golang-1-linux/d' "$job_dir/spec" || true
                
                # Remove references to packages we deleted
                for pkg in $GOLANG_PACKAGES; do
                  sed -i "/- $pkg/d" "$job_dir/spec" || true
                  sed -i "/$pkg/d" "$job_dir/spec" || true
                done
                
                echo "Updated job spec for: $job_name"
                echo "Current packages in $job_name spec:"
                grep -A 20 "packages:" "$job_dir/spec" || echo "No packages section found"
              fi
            done
          fi
          
          # Create a new blobs.yml with only rootfs
          cat > config/blobs.yml << EOF
        rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz:
          size: $(stat -c%s "blobs/rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz")
          sha: $(sha1sum "blobs/rootfs/${{ inputs.stack }}-${{ inputs.version }}.tar.gz" | cut -d' ' -f1)
        rootfs/${{ inputs.stack }}.tar.gz:
          size: $(stat -c%s "blobs/rootfs/${{ inputs.stack }}.tar.gz")
          sha: $(sha1sum "blobs/rootfs/${{ inputs.stack }}.tar.gz" | cut -d' ' -f1)
        EOF
          
          echo "=== Final release structure ==="
          echo "Remaining packages:"
          ls -la packages/ || echo "No packages directory"
          echo "Jobs:"
          ls -la jobs/ || echo "No jobs directory"
          
          echo "Created new blobs.yml:"
          cat config/blobs.yml
          
          echo "Contents of blobs directory:"
          find blobs -type f -exec ls -la {} \;
          
          # Create release as dev version (bypasses blobstore entirely)
          echo "Creating development release..."
          bosh create-release --force --version="dev-$(date +%s)" --tarball="../rootfs-release-artifacts/${{ inputs.stack }}-dev.tgz"
          
          # Create ops file for this dev release
          DEV_VERSION="dev-$(date +%s)"
          cat > ../rootfs-release-artifacts/use-dev-release-opsfile.yml << EOF
        - type: replace
          path: /releases/name=${{ inputs.stack }}?
          value:
            name: ${{ inputs.stack }}
            version: "$DEV_VERSION"
            url: file://\$(pwd)/rootfs-release-artifacts/${{ inputs.stack }}-dev.tgz
        EOF
        else
          echo "ERROR: No rootfs tarball found at ../rootfs-artifacts/${{ inputs.stack }}-${{ inputs.version }}.tar.gz"
          exit 1
        fi

    - name: Upload ubuntu-noble stemcell
      shell: bash
      run: |
        cd deployment-source-config
        source source_file.yml
        cd ..
        bosh upload-stemcell gcp-stemcell.tgz --non-interactive

    - name: Upload rootfs release to BOSH director
      shell: bash
      run: |
        cd deployment-source-config
        source source_file.yml
        cd ..
        
        if [[ -f "rootfs-release-artifacts/${{ inputs.stack }}-dev.tgz" ]]; then
          echo "Uploading rootfs release..."
          bosh upload-release "rootfs-release-artifacts/${{ inputs.stack }}-dev.tgz" --non-interactive
        else
          echo "ERROR: Rootfs release tarball not found"
          exit 1
        fi

    - name: Create CAPI release
      shell: bash
      run: |
        cd capi-release
        bosh create-release --force --tarball="../capi-release-artifacts/capi-dev.tgz"
        
        # Create ops file for this dev release
        cat > ../capi-release-artifacts/use-dev-release-opsfile.yml << EOF
        - type: replace
          path: /releases/name=capi?
          value:
            name: capi
            version: create
            url: file://\$(pwd)/capi-release-artifacts/capi-dev.tgz
        EOF

    - name: Upload CAPI release to BOSH director
      shell: bash
      run: |
        cd deployment-source-config
        source source_file.yml
        cd ..
        
        echo "Uploading CAPI release..."
        bosh upload-release "capi-release-artifacts/capi-dev.tgz" --non-interactive

    - name: Create buildpack ops file
      shell: bash
      run: |
        # Create empty buildpack ops file for now
        cat > buildpacks-opsfile/use-latest-buildpack-releases.yml << 'EOF'
        # Placeholder for buildpack release operations
        EOF

    - name: Copy rootfs smoke test manifest
      shell: bash
      run: |
        cp ${{ inputs.stack }}-release/manifests/manifest.yml rootfs-release-artifacts/manifests/manifest.yml

    - name: Deploy rootfs smoke test
      shell: bash
      run: |
        cd deployment-source-config
        source source_file.yml
        
        echo "Deploying rootfs smoke test..."
        bosh -d rootfs-smoke-test deploy \
          ../rootfs-release-artifacts/manifests/manifest.yml \
          --vars-store smoke-test-vars.yml \
          --non-interactive

    - name: Run rootfs smoke test
      shell: bash
      run: |
        set -euo pipefail
        cd deployment-source-config
        source source_file.yml
        cd ..
        
        echo "Running rootfs smoke tests..."
        bosh -d rootfs-smoke-test run-errand smoke-tests

    - name: Deploy CF
      id: deploy
      shell: bash
      run: |
        set -euo pipefail
        cd deployment-source-config
        source source_file.yml
        
        echo "Deploying Cloud Foundry..."
        bosh -d cf deploy ../cf-deployment/cf-deployment.yml \
          --ops-file ../cf-deployment/operations/experimental/fast-deploy-with-downtime-and-danger.yml \
          --ops-file ../cf-deployment/operations/use-latest-stemcell.yml \
          --ops-file ../cf-deployment/operations/use-compiled-releases.yml \
          --ops-file ../cf-deployment/operations/experimental/add-${{ inputs.stack }}.yml \
          --ops-file ../cf-deployment/operations/experimental/set-${{ inputs.stack }}-default-stack.yml \
          --ops-file ../buildpacks-opsfile/use-latest-buildpack-releases.yml \
          --var system_domain='${{ inputs.system_domain }}' \
          --vars-store cf-vars.yml \
          --non-interactive

        echo "success=true" >> $GITHUB_OUTPUT